# Graphical user interface (GUI) repository of the 2023 SenSwiss Team

**Table of content:**
  - [Structure](#structure)
  - [Installation](#installation)
  - [Description](#description)
    - [Interface](#interface)
    - [Microfluidic system](#microfluidic-system)
      - [Manual](#manual)
      - [Semi-automatic](#semi-automatic)
      - [Automatic](#automatic)
    - [Camera](#camera)
    - [Spectrometer](#spectrometer)
    - [Arduino \& DC motor](#arduino--dc-motor)
    - [Protocols](#protocols)
  - [Usage](#usage)
  - [Results](#results)
  - [Authors](#authors)

<a id="Structure"></a>
## Structure
The GUI repository of the 2023 SenSwiss Team is organized as follows:
- `image_saved`: stores the images taken by the camera or the spectrographs taken by the spectrometer during the experiments.
- `layout_figures`: contains the figures used in the GUI
- `plots_saved`: stores the data plots generated by the GUI
- `protocols`: stores the protocols used for the experiments; these protocols can be defined and directly loaded in the GUI
- **arduino_control.py**: contains the code to control the Arduino board
- **control_flir_camera.py**: contains the code to control the camera
- **gui.py**: contains the code of the GUI
- **imgproc.py**: contains the main functions to process the images taken by the camera and the spectrographs taken by the spectrometer
- **layout.py**: contains the code to define the layout of the GUI
- **microflu.py**: contains the code to control the microfluidic system

<a id="Installation"></a>
## Installation
To run the code, you will need to install several packages. The easiest way to do so is to use the Anaconda distribution. You can download it [here](https://www.anaconda.com/products/individual). Once Anaconda is installed, you can create a new environment and install the packages using the following commands in the Anaconda prompt:
```
conda create -n senswiss python=3.10
conda activate senswiss
```
Then, you can install the packages using the following commands:
```
pip install name_of_the_library
```

<a id="Description"></a>
## Description
This miniprogram allows the user to control the different systems of the sensor and to perform experiments. The GUI can be used in two modes: with a camera or with a spectrometer, depending on which measurement is better suited for the experiment. The GUI will then automatically adapt the interface to the plugged in measurement device.

The GUI is divided into 3 parts:
- **Microfluidics section**, which controls the pump;
- **Measurement device section**, which controls either the camera or the spectrometer depending on which is plugged in, processes and displays the signal over time
- **Motor control section**, which controls the DC motor to open or close the measurement chamber


<a id="Interface"></a>
### Interface
The GUI is presented as follows, displaying on the left the image/spectrograph and the signal over time, and on the right the control buttons and the parameters to set.

<a id="Microfluidic-system"></a>
### Microfluidic system
The microfluidic section contains all buttons to control the integrated pump system ([AMF LSPone](https://amf.ch/produit/lspone-laboratory-syringe-pump/)). The pump is a 12 valves microfluidic system that allows to pick and dispense a volume of 8-250 mL at a flowrate of 25-7'500 $\mu L$/min.

The microfluidic system is highly customizable and allows for the choice of three modalities: **Manual**, **Semi-Automatic**, **Automatic**.

In all modes, the following buttons are available:
- `Reconnect pump`: reconnects the pump to the computer in the case wheter it disconnected during the experiment;
- `Stop and trash`: stops the current pump command and trashes the remaining volume in the trash reservoir (valve 1);
- `Reinitialize`: reinitializes the pump system, i.e. sets all valves to the initial position (valve 1);
- `Kick out bubble`: sends a short series of pulses to the pump to kick out any bubble in the microfluidic system. The user has to specify the input and output valves and then the program sends preprogrammed instructions to the pump.

#### Manual
![Microflu_manual](layout_figures/Microflu_manual.jpg)

Every command has to be defined manually one at a time. The possible commands are the following:
- `Switch to valve`: the pump selects the valve according to the user input;
- `Set speed`: the user defines the flowrate of the pump in $\mu L$/min;
- `Pickup uL`: the user defines the volume to pick up (in $\mu L$) from the chosen valve;
- `Dispense uL`: the user defines the volume to dispense (in $\mu L$L) from the chosen valve;
- `Heat ON`: the user defines the temperature of the heating plate (in °C) and sets the heating plate ON;
- `Heat OFF`: the user sets the heating plate OFF.

#### Semi-automatic
![Microflu_semiauto](layout_figures/Microflu_semiauto.jpg)

The semi-automatic mode allows the user to define a protocol of commands that will be executed sequentially. The user can add new command lines by clicking on the `+` button, and then specify the different inputs as follows:
- `Port`: the user defines the valves to use
- `Action`: the user selects the actions to execute from the drop-down list (Pick or Dispense)
- `Volume`: the user defines the volume to pick or dispense (in $\mu L$)
- `Speed`: the user defines the flowrate of the pump (in $\mu L$/min)
- `Title`: the user specifies a title for the command line (optional), this title will be added to the data file of the experiment at the corresponding timepoint when the sample is dispensed into the chamber (the program automatically computes the required time given the volume and the flowrate and the fixed tubing length)
- `Wait`: adds a waiting step of a user specified duration (in miliseconds) before executing the next command line
- `copy`: the copy checkbox allows to select the line to copy, the user can then paste the line by clicking on the `Copy commands` button
- `Delete`: the user can delete the line by clicking on the `Delete` button

The list of commands can be saved by clicking on the `Save commands` button. The filename is to be specified by the user. The protocol will be saved in the protocols folder as a **.csv** file. If the user loads a protocol from the automatic section, the program will automatically load the protocol and display it in the list of commands in the semi-automatic section. The user can then edit the protocol and save it under a different name.

The user can clear the whole command pannel by clicking on the `Delete all` button.

Finally, the user can send the protocol to the pump for it to be sequentially executed by clicking on the `Send` button. The program will concatenate all the command **strings** into a big command **string** and send it to the pump which will then dissect it and execute the instruction one by one. This communication way prevent the lists of commands from being too long. An empirical maximum is at 22 command lines.

#### Automatic
![Microflu_auto](layout_figures/Microflu_auto.jpg)

The automatic mode allows to execute prewritten protocols. The user can either select and directly send a protocol to the pump for it to be executed via the `Send protocol` button, or they can select and load a protocol into the semi-automatic section by clicking on the `Load protocol` button. The protocol will be loaded and displayed in the list of commands. The user can then edit the protocol and save it under a different name.

<a id="Camera"></a>
### Camera
GUI in camera mode:
![ROI in automatic mode](layout_figures/ROI_auto.jpg)

On the top left, the real time image of the camera ([FLIR Blackfly S USB3](https://www.flir.fr/products/blackfly-s-usb3/?vertical=machine%20vision&segment=iis))is displayed.

In the command pannel on the right, in the section `Camera settings`, the user can set different parameters to improve the signal reading and control the camera. The program enables the extraction of a Region Of Interest (ROI) from the camera image, via intensity threshold filtering. The user can set the parameter for the detection of the ROI by changing the `Kernel size`, the `Number of dilations` and the `Threshold value`. The program will then apply a Gaussian smoothing (of empirical size (15,15)), compute a threshold mask from the smoothed image, dilate the mask a certain number of times with the squared kernel and determine the ROI as the centroid of the mask image (via the `cv2.moments` function). The ROI is then displayed on the camera image (top left). It can also be set manually by the user by clicking on the camera image. The ROI's shape (rectangular or cicular) and shape's parameters can be set by the user via the appropriate drop-down list or input fields.

The ROI is then used to compute the signal by simply averaging the intensity over the ROI surface. This signal is then displayed overtime in relative 8 bits intensity pixel level unit on the bottom left window.

The user can also set specific camera parameters such as the `Exposure time` and the `Gain` via the appropriate input fields. These parameters vary the intensity of the signal (the higher the exposure time and the gain, the higher the intensity of the signal).

The user can save a picture of the camera image by clicking on the `Save image` button. The image will be saved in the `image_saved` folder as a **.png** file. The user can name the image file via the adjacent input field, in any case, the image will be saved with the current date and time.

Finally, the user can fine tune the display of the processed signal by setting y-axis limits via the appropriate input fields (min and max). Additionally, they can choose to set these values automatically by clicking on the `Auto` checkbox, the program will then automatically set the y-axis limits to the minimum and maximum values of the signal. The plot of the signal overtime can be saved via the `Save plot` button. The plot will be saved in the `plots_saved` folder as a **.csv** file. The user can name the plot file via the adjacent input field, in any case, the plot will be saved with the current date and time.

The original idea was to use the intensity of the optical signal measured by a camera to detect the concentration of the sample. However, this method was found to be not sensitive enough. Hence, we decided to rely on the wavelenght shift, measured by a spectrometer to detect the concentration of the sample.

<a id="Spectrometer"></a>
### Spectrometer
GUI in spectrometer mode:
![ROI in automatic mode](layout_figures/GUI_general.jpg)

On the top left, the real time spectrograph of the spectrometer ([MAYA 2000 PRO](https://www.gmp.ch/spectroscopy/spectrometer/high-sensitivity-uv-spectrometers-maya))is displayed.

In the command pannel on the right, in the section `Spectrometer settings`, the user can set different parameters to improve the signal reading and control the spectrometer.

The sampling period of the spectrometer signal can be set via the button `Acquisition period`. By default the sampling period is at 0.5 sec, setting of a good compromise between the signal quality and the computational cost.

In case the spectrometer disconnects from the system, the user can reconnect the spectrometer via the `Reconnect spectrometer` button. The program will then automatically detect the spectrometer and ensure its connection to the system.

The signal of the spectrometer (intensity spectrum along wavelengths from 500 to 900 nm) is normalized via the following step:

$$normalized\ intensity\ spectrum = \frac{intensity\ spectrum\ -\ dark\ field}{flat\ field \ -\ dark\ field}  \ normalize\ gain$$

While the **intensity spectrum** (`intensities_spec`) is the raw signal from the spectrometer, the **dark field** (`dark_field`) is the signal of the spectrometer when the light source is off, the **flat field** (`flat_field`) is the signal of the spectrometer when the light source is on and the polarizer is at 90° from its reference angle for the true measurements (the user has to manually set the polarizer at 90° to save the flat field), and the **normalize gain** (`normalize_gain`) is a constant computed as the mean value of the difference between the flat and dark fields (flat field - dark field). 
The dark field and the flat field are to be measured at the beginning of the experiment via the appropriate buttons and are stored in memory for the entire experiment. The flat field corresponds to the optical signal as if the target (sample and chip) acted as a perfect mirror. This normalization allows to get rid of the background signal and improves the sensitivity. The normalized spectrum is then displayed in relative intensity level unit on the top left window. The user can save the spectrograph by clicking on the `Save spectrograph` button. The spectrograph will be saved in the `image_saved` folder as a **.png** file. The user can name the spectrograph file via the adjacent input field, in any case, the spectrograph will be saved with the current date and time.

The concept behind spectrometry measurement involves leveraging the shift in absorption peaks on the chip's surface as a function of sample concentration. This shift is made possible by the significant signal enhancement effect of [surface plasmon resonance], which occurs at the chip's surface. (https://en.wikipedia.org/wiki/Surface_plasmon_resonance). The absorption peak is detected by computing the minimum of the normalized spectrum. This signal is then displayed over time on the bottom left window. As a good signal-to-noise ratio is crucial for optimal detection, different denoising methods have been implemented to improve the signal quality.

Firstly, we implemented a simple moving average filter. The window can be chosen by the user via the `Set moving average window` and its adjacent input field. The filtered signal is plotted on the bottom left window. This denoising method proved not to be effective enough. Hence, a Savitzy-Golay filter was added to smooth the intensities signal before normalizing. The window can be chosen by the user via the `Set SG window` and its adjacent input field. The filtered signal is also plotted on the bottom left window.

Having found the previous methods not effective enough, we implemented a further denoising filter. This involves calculating the centroid of the signal in a fixed wavelenghts window set by the user at the beginning of the experiment during calibration. The user can set the window size by filling the input field `Window width for centroid` and clicking on the `Reset mean peak` button to set the window. The window will then be fixed around the the wavelength of the minimum intensity peak in the normalized spectrograph. This window is fixed for the entire experiment and then the program computes the centroid of the signal in this window. The centroid signal is then again displayed on the bottom left window. This method proved to be the most effective for signal denoising.

To better visualize the signal throughout the different steps of the experiment ( for instance when adding certain buffers, reactants or the concentration sample), the user can add markers to the plot. To do so the user can simply insert the necessary comment via the `Add comment` button and the adjacent input field. The comment will be graphically added in the plot by a labeled vertical dashed line at the corresponding timepoint.

If necessary, the user can clear the plot by clicking on the `Clear plot` button.

The user can fine tune the display of the processed signal by setting y-axis limits via the appropriate input fields (min and max), or can choose to set these values automatically by clicking on the `Auto` checkbox. The plot of the signal overtime can be saved via the `Save plot` button. The plot will be saved in the `plots_saved` folder as a **.csv** file. The user can name the plot file via the adjacent input field, in any case, the plot will be saved with the current date and time.

Finally, to compute the shift in absorbance peak, the user has to mention the **reference** and **measure** events of the measurement (e.g. GFAP, STOP) via the two input fields and click on the `Compute shift` button. The program will then automatically measure the wavelength shift between the mean value (stable plateau) at the reference event and the mean value at the measure event; The code for this is in the `compute_shift` function in the **imgproc.py** file. This shift value can then be related to the sample concentration of analyte using the calibration curve.

<a id="Arduino-&-DC-motor"></a>
### Arduino & DC motor
The measuring chamber is opened and closed by a mechano-electrical simple system in order to ensure good reproducibility and ideal sealing of the chamber to avoid leaks in the microfluidics system. The system is composed of a DC motor simple gear system that allow vertical movement of the 3D printed chip holder. The DC motor is controlled by an Arduino Leonardo board. The Arduino code is contained in the [ARDUINO CONTROL](https://github.com/ArthurEglin/SenSwiss2023/tree/main/SenSwiss2023/ARDUINO%20CONTROL/src) folder.

The user can control the DC motor via the `Motor` section in the GUI. The user can open or close the chamber by clicking on the `Open chamber` or `Close chamber` buttons. The user can also stop the motor at any time via the `Stop DC motor` button. To ensure that the motor does not damage the measuring chamber, its torque is constantly monitored and controlled by the Arduino (since the torque is directly proportional to the applied current). It is therefore possible that the torque limit defined in the code is reached too soon if some additional friction is applied on the motor and gear system (rust, small offset). In this case, click again on the `Close chamber` button to close the measuring chamber.

If the Arduino gets disconnected, the user can reconnect it via the `Reconnect Arduino` button. The program will then automatically detect the Arduino and connect to it.

![Motor control](layout_figures/Motor_control.jpg)

<a id="Protocols"></a>
### Protocols

During experiments, protocols can be loaded directly into the User Interface and saved in the `protocols` folder. These protocols are stored in **.csv** files, making it possible to manually modify them if needed and reload them in the GUI for future experiments, ultimately saving a lot of time.

Below an example of a protocol file is displayed (**Olygo_83cc.csv**):

![Protocol](layout_figures/Protocol.png)

The data in the table is structured as follows: 

- The first column specifies the valve at which the action is executed
- The second column indicates the type of action, which can be either "Pick" or "Dispense"
- The third column indicates the volume associated with the action
- The fourth column contains the flowrate for that particular action
- The fifth column is optional and serves as a title, which is essential for identifying specific segments of the signal to compute shifts and sample concentrations, the title of each command is visually represented in the plot as a vertical and labeled dashed line
- The sixth column is optional and allows the user to specify a waiting time between two actions

<a id="Usage"></a>
## Usage
To run the GUI, you can use the following command in the Anaconda prompt after activating the environment:
```
python gui.py
```
Be sure to check that the necessary devices (camera/spectrometer, pump, arduino) are connected to the computer before running the GUI.

The procedure for running an experiment with the spectrometer is as follows:

1. insert the chip in the holder and place it on the rail, close the measurement chamber by clicking on the `Close chamber` button
2. fill all the tubings with the appropriate buffers, for this the user can use prewritten protocols in the `protocols`` folder 
3. fill the chambers with the appropriate buffers, for this the user can use prewritten protocols in the `protocols`` folder
4. calibrate the optics
  4.1 align the light beam to the center of the chamber and the reflected light beam to the center of the spectrometer
  4.2 set dark field by clicking on the `Save dark field` button when the light beam is off
  4.3 set flat field by clicking on the `Save flat field` button when the light beam is on and the polarizer is at 90° from its reference angle, the reference angle can either be for TE or TM light (depending on the grating orientation of the chip), but the flat field must always be the opposite of the reference angle (e.g. if the reference angle is for TE light, the flat field must be for TM light)
4. display the normalized spectrograph by clicking on the `Normalized` checkbox, then fix the window for the centroid computation by clicking on the `Reset mean peak` button
5. write or select the protocol and execute it by clicking on the `Send` button
6. compute the shift by clicking on the `Compute shift` button
7. save the spectrograph and the plot by clicking on the `Save spectrograph` and `Save plot` buttons

<a id="Results"></a>
## Results


The initial plan involved fitting the segments of the signal with an exponential function after applying GFAP. The intention was to save the parameters of the exponential function for each segment and utilize them to train a Machine Learning model for predicting the concentration of the sample under examination. This approach required a substantial amount of data to be collected. Unfortunately, due to the challenges faced by the SenSwiss team in 2023, this data collection could not be accomplished. Nevertheless, the functions for fitting the exponential functions are stored in 'imgproc.py' and remain available for use by future teams.

The classification of each sample (from Very Low to Very High Concentration) was hence computed by fitting two linear regression curves (Normalized signal and Centroid) . 


<a id="Authors"></a>
## Authors
- [**Marin Bricq**](https://github.com/MBricq)
- [**Arthur Eglin**](https://github.com/ArthurEglin)
- [**Elena Gado**](https://github.com/ElenaGrazia)
